<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Bar-Tailed Godwit FLightR analysis}
%\VignetteDepends{FLightR}
-->
# Intigeo tag on a Bar tailed godwit analysis example
# FLightR analysis
This is a new workflow for FLightR>=0.3.8 based on the original Appendix A6 to 
Rakhimberdiev, E., Senner, N. R., Verhoeven, M. A., Winkler, D. W., Bouten, W. and Piersma T. 2016 Comparing inferences of solar geolocation data against high-precision GPS data: annual movements of a double-tagged Black-Tailed Godwit. - Journal of Avian Biology 000: 000-000.

## Install package
We used FLightR 0.3.8 version, so you might want to install it if you want to get exactly the same results.

```{r, eval = F}
library(devtools)
install_github("eldarrak/FLightR@0.3.9") # note the version
library(FLightR)
```
##Defining twilights and data input
The analysis of geolocation data typically begins with defining twilight events (sunrises and sunsets). There is no such function implemented in the FlightR. We therefore recommend to use appropriate functions from TAGs, BAStag or GeoLight for this purpose.

In the [appendix A4](https://github.com/eldarrak/FLightR/blob/master/examples/Black-Tailed_Godwit_JAB_example/A4_BAStag_routine.Rmd) we show how to define twilights with [BAStag package] (https://github.com/SWotherspoon/BAStag). To practice defining twilights yourself, the raw light-level data obtained from the tag in a lux format(as you get it from the Migrate Technology Ltd geolocators). You can also download the [.csv] with pre-defined twilight events (https://raw.githubusercontent.com/eldarrak/FLightR/master/examples/Black-Tailed_Godwit_JAB_example/A3_TAGS_format.csv) file from the directory and process these data:
```{r, eval=FALSE, tidy=FALSE}
download.file(
 "https://raw.githubusercontent.com/eldarrak/FLightR/master/examples/Black-Tailed_Godwit_JAB_example/A3_TAGS_format.csv",
 "A3_TAGS_format.csv")

Proc.data<-get.tags.data("A3_TAGS_format.csv")
```
 
##Calibration

All geolocators measure light levels with different precision, and calibration is needed to find the relationship between the measured and real light levels for each device. This relationship is depicted by the calibration parameters, which are calculated based on the data recorded in known (calibration) locations.  Such locations can be the ones, where the animal was tagged, recaptured or observed. A "roof top" treatment of a tag (getting a perod of records from a tag put in an open place, before deployment)is a recommended source of calibration data.

For the data recorded by a deployed on an animal tag, the exact period of its stay in a known location is usually not known, but it can be estimated from the data. For this, we obtain and plot calibration slopes for sunsets and sunrises for every day of the tracking period, based on the assumption that the tag remained in the same calibration location all the time. 

add calibration location as x,y
```{r, eval = F}
plot.slopes.by.location(Proc.data=Proc.data, location=c(5.43, 52.93))
```

Looking at the plot, we can define the time periods, during which the tag really was in the calibration location (recall, that we assume that the tag remained in this location all the time). Because calibration slopes reflect the adequacy of the light level measured by the device, they vary little, in time and between sunsets and sunrises, as long as the tagged animal stays in the calibration location, but become clearly diverse, when it moves away from it. Both patterns are clearly distinguishable at the plot. 

Play with `abline()` to find the proper boundaries for the calibration.
```{r, eval = F}
abline(v=as.POSIXct("2013-08-20")) # end of first calibration period
abline(v=as.POSIXct("2014-05-05")) # start of the second calibration period
```
In this example, we have two calibration periods (in the same location), in the beginning and at the end of the track. This is a common case, as the birds are oftentimes recaptured at the same location, where they were tagged.

Note, that if there are more than one calibration locations, the procedure above has to be repeated for each of the locations. 

The next step is to create a data.frame, in which a separate line is designated for each of the calibration periods. The columns are: (1) start of the calibration period, (2) end of the calibration period, (3) longitude of the calibration location and, (4) latitude of the calibration location.

```{r, eval = F}
Calibration.periods<-data.frame(
        calibration.start=as.POSIXct(c(NA, "2014-05-05")),
        calibration.stop=as.POSIXct(c("2013-08-20", NA)),
        lon=5.43, lat=52.93) #use c() also for the geographic coordinates, if you have more than one calibration location (e. g.,  lon=c(5.43, 6.00), lat=c(52.93,52.94))
print(Calibration.periods)
```

Using the created data frame with the calibration periods and locations and the object with light data and twilight events (Proc.data), we estimate calibration parameters for each of the periods and make a calibration object. This object will be used for the calculation of geographic positions later on...
```{r, eval = F}
Calibration<-make.calibration(Proc.data, Calibration.periods)
#Use model.ageing=TRUE, if you wish to account for opacification of the tag's shell. Note, this is only possible, if there are more than one calibration periods.
```

## Spatial extent
Set up a spatial grid (50 X 50 km on default) `left`, `right`. `bottom` and `top` are specific boundaries for your bounding box. `distance.from.land.allowed.to.use` should be vector with length of two, first number is negative distance allowed to use while over land, and second is distance from land allowed to use while over water.
`distance.from.land.allowed.to.stay` should be vector with length of two, first number is negative distance where bird is allowed to be stationary, and second is distance from land allowed to fly over during twilight while over water.
```{r, eval = F}
Grid<-make.grid(left=-14, bottom=30, right=13, top=57, distance.from.land.allowed.to.use=c(-Inf, Inf), distance.from.land.allowed.to.stay=c(-Inf, Inf))
```
## Create proposal

Here we create a complex object, which will be used in the main run. It incorporates all the objects, created at earlier steps: the light data with the detected twilight events (Proc.data), the spatial parameters (Grid), geographic coordinates of the initial location, where the tracking has started (start), and the calibration parameters (Calibration).

```{r, eval = F}
all.in<-make.prerun.object(Proc.data, Grid, start=c(5.43, 52.93), Calibration=Calibration)
```
##Run particle filter

At this stage, coordinates are calculated (coordinates, behavior, stationarity).
Within the function run.particle.filter, the following parameters can be preset: 

 -number of particles (1e4 is recommended for test and 1e6 for the analysis)
 -known.last = TRUE if you know that in the end of data collection tag was in a known place (FALSE is the default option)
 -check.outliers = TRUE, for the "on a fly" discard of outliers (only recommended if you wish to obtain a beautiful and smooth visualisation of a track). 

   
```{r, eval = F}

nParticles=1e6
a= Sys.time()
Result<-run.particle.filter(all.in, save.Res=F, threads=-1,
                nParticles=nParticles, known.last=TRUE,
		precision.sd=25, save.memory=T, k=NA,
		parallel=T,  plot=T, prefix="pf",
		extend.prefix=T, cluster.type="SOCK",
		a=45, b=1500, L=90, adaptive.resampling=0.99, check.outliers=F)
b= Sys.time()
b-a
save(Result, file="Result.bltg.ageing.model.noOD.RData")

```
Now your results are saved in your work directory as an RData object.

#Below is old workflow that will be updated soon
## Plotting the results

### Plot a simple map
```{r, eval = F}

par(mfrow=c(1,1))
par(mar=c(4,4,3,1),las=1,mgp=c(2.25,1,0))

#--------------------------------------------------------
# we can plot either mean or median.

Mean_coords<-cbind(Result$Results$Quantiles$Meanlon, Result$Results$Quantiles$Meanlat)
if (is.null(Result$Results$Quantiles$MedianlatJ)) {
	Median_coords<-cbind(Result$Results$Quantiles$Medianlon, Result$Results$Quantiles$Medianlat)
} else {
	Median_coords<-cbind(Result$Results$Quantiles$MedianlonJ, Result$Results$Quantiles$MedianlatJ)
}
plot(Median_coords, type = "n",ylab="Latitude",xlab="Longitude")
library(maptools)
data(wrld_simpl)
plot(wrld_simpl, add = T, col = "grey95", border="grey70")
lines(Median_coords, col = "darkgray", cex = 0.1)
points(Median_coords, pch = 16, cex = 0.75, col = "darkgray")
lines(Mean_coords, col = "blue", cex = 0.1)
points(Mean_coords, pch = 16, cex = 0.75, col = "blue")
box()
```
### Plot lon lat graph
```{r, eval = F}
Quantiles<-Result$Results$Quantiles
par(mfrow=c(2,1))
par(mar=c(2,4,3,1),cex=1)
 Sys.setlocale("LC_ALL", "English")  

#Longitude
plot(Quantiles$Medianlon~Quantiles$time, las=1,col=grey(0.1),pch=16,
     ylab="Longitude",xlab="",lwd=2, ylim=range(c( Quantiles$LCI.lon,
	 Quantiles$UCI.lon )), type="n")


polygon(x=c(Quantiles$time, rev(Quantiles$time)), y=c(Quantiles$LCI.lon, rev(Quantiles$UCI.lon)),
         col=grey(0.9), border=grey(0.5))

polygon(x=c(Quantiles$time, rev(Quantiles$time)), y=c(Quantiles$TrdQu.lon, rev(Quantiles$FstQu.lon)),
         col=grey(0.7), border=grey(0.5))

lines(Quantiles$Medianlon~Quantiles$time, col=grey(0.1),lwd=2)


abline(v=as.POSIXct("2013-09-22 21:34:30 EDT"), col=1, lwd=1, lty=2)
abline(v=as.POSIXct("2014-03-22 21:34:30 EDT"), col=1, lwd=1, lty=2)

#Latitude
par(mar=c(3,4,1,1))

plot(Quantiles$Medianlat~Quantiles$time, las=1,col=grey(0.1),
     pch=16,ylab="Latitude",xlab="",lwd=2,
	 ylim=range(c( Quantiles$UCI.lat, Quantiles$LCI.lat )), type="n")

polygon(x=c(Quantiles$time, rev(Quantiles$time)), y=c(Quantiles$LCI.lat, rev(Quantiles$UCI.lat)),
           col=grey(0.9), border=grey(0.5))

polygon(x=c(Quantiles$time, rev(Quantiles$time)), y=c(Quantiles$TrdQu.lat, rev(Quantiles$FstQu.lat)),
           col=grey(0.7), border=grey(0.5))

lines(Quantiles$Medianlat~Quantiles$time, col=grey(0.1),lwd=2)

abline(v=as.POSIXct("2013-09-22 21:34:30 EDT"), col=1, lwd=1, lty=2)
abline(v=as.POSIXct("2014-03-22 21:34:30 EDT"), col=1, lwd=1, lty=2)
```
## Migration schedules
We can extract departure arrival estimates from the results we have got. 
First select grid points that are of interest. For example in the current data we are interested to figure out when our bird left the Netherlands. We will make  a boundary at Lat 2&deg;
```{r, eval = F}
Index<-which(Result$Spatial$Grid[,1]>(2))
```
And now I estimate probabilities if being in the area for each twilight:
```{r, eval = F}
Prob.of.being.in.NL<-get.prob.of.being.in(Result, Index)

Times.NL=find.times.distribution(Prob.of.being.in.NL,Result$Indices$Matrix.Index.Table$time)

Times.NL
```

This is it so far... There are of course many more things one could do with the data and we plan to show them in the other manuscripts.
